#!/usr/bin/env python

from __future__ import division
from __future__ import print_function
import argparse
import textwrap
import os
import glob
import pandas as pd
from collections import OrderedDict
from framed import Community, Environment, set_default_solver
from framed.experimental.medium import load_media_db
from smetana import mip_score, mro_score, species_coupling_score, metabolite_production_score, metabolite_uptake_score, minimal_environment
from random import sample
from framed.io.cache import ModelCache


def extract_id_from_filepath(filepath):
    filename = os.path.basename(filepath)

    if filename.endswith('.xml'):
        organism_id = filename[:-4]
    elif filename.endswith('.xml.gz'):
        organism_id = filename[:-7]
    else:
        raise IOError('Unrecognized extension in file {}. Valid extensions are .xml and .xml.gz'.format(filename))

    return organism_id


def build_cache(models, flavor=None):
    ids = [extract_id_from_filepath(model) for model in models]

    if not flavor:
        flavor = 'fbc2'

    load_args = {'flavor': flavor}

    def post_process(model):
        if 'R_ATPM' in model.reactions:
            model.reactions.R_ATPM.lb = 0

    return ModelCache(ids, models, load_args=load_args, post_processing=post_process)


def load_communities(models, communities, other, flavor):

    if len(models) == 1 and '*' in models[0]:
        pattern = models[0]
        models = glob.glob(pattern)
        if len(models) == 0:
            raise RuntimeError("No files found: {}".format(pattern))

    if other is not None:
        df = pd.read_csv(other, header=None)
        other_models = set(df[0])
    else:
        other_models = set()

    model_cache = build_cache(models, flavor)

    if communities is not None:
        df = pd.read_csv(communities, sep='\t', header=None, dtype=str)
        comm_dict = OrderedDict((name, group[1].tolist()) for name, group in df.groupby(0))
    else:
        comm_dict = {'all': model_cache.get_ids()}

    if other:
        missing = other_models - set(model_cache.get_ids())
        if missing:
            print("Warning: {} models in perturbation file missing.".format(len(missing)))

    return model_cache, comm_dict, other_models


def load_media(media, mediadb, exclude, other):

    media_db = None

    if media:
        if mediadb is None:
            raise IOError('Please provide media library with --mediadb option.')
        else:
            media_db = load_media_db(mediadb)
        media = media.split(',')
    else:
        media = [None]

    if exclude:
        df = pd.read_csv(exclude, header=None)
        excluded_mets = set(df[0])
    else:
        excluded_mets = set()

    if other:
        df = pd.read_csv(other, header=None)
        other_mets = set(df[0])
    else:
        other_mets = set()

    return media, media_db, excluded_mets, other_mets


def define_environment(medium, media_db, community, mode, verbose, min_mol_weight, use_lp):

    max_uptake = 10.0 * len(community.organisms)

    if medium:
        env = Environment.from_compounds(media_db[medium], exchange_format="'R_EX_M_{}_e_pool'", max_uptake=max_uptake)
        medium_id = medium
    elif mode == "global":
        env = Environment.complete(community.merged, max_uptake=max_uptake)
        medium_id = 'complete'
    else:
        env = minimal_environment(community, verbose=verbose, min_mol_weight=min_mol_weight, use_lp=use_lp, max_uptake=max_uptake)
        medium_id = "minimal"

    return medium_id, env


def run_global(comm_id, community, organisms, medium_id, excluded_mets, env, verbose, min_mol_weight, use_lp, debug):

    global_data = []
    debug_data = []

    if verbose:
        print('Running MIP for community {} on medium {}...'.format(comm_id, medium_id))

    mip, extras = mip_score(community, environment=env, verbose=verbose,
                            min_mol_weight=min_mol_weight, use_lp=use_lp, exclude=excluded_mets)

    if mip is None:
        mip = 'n/a'

    if debug and extras is not None:
        mip_ni = ','.join(sorted(extras['noninteracting_medium']))
        mip_i = ','.join(sorted(extras['interacting_medium']))
        debug_data.append((comm_id, medium_id, 'mip', 'ni', mip_ni))
        debug_data.append((comm_id, medium_id, 'mip', 'i', mip_i))

    if verbose:
        print('Running MRO for community {} on medium {}...'.format(comm_id, medium_id))

    mro, extras = mro_score(community, environment=env, verbose=verbose,
                            min_mol_weight=min_mol_weight, use_lp=use_lp, exclude=excluded_mets)

    if mro is None:
        mro = 'n/a'

    if debug and extras is not None:
        comm_medium = ','.join(sorted(extras['community_medium']))
        debug_data.append((comm_id, medium_id, 'mro', 'community', comm_medium))
        for org, values in extras['individual_media'].items():
            org_medium = ','.join(sorted(values))
            debug_data.append((comm_id, medium_id, 'mro', org, org_medium))

    global_data.append((comm_id, medium_id, len(organisms), mip, mro))

    return global_data, debug_data


def run_detailed(comm_id, community, medium_id, excluded_mets, env, verbose, min_mol_weight, ignore_coupling):

    smt_data = []

    exclude_bigg = {'M_{}_e'.format(x) for x in excluded_mets}

    if not ignore_coupling:
        if verbose:
            print('Running SCS for community {} on medium {}...'.format(comm_id, medium_id))

        scs = species_coupling_score(community, environment=env, verbose=verbose)

    if verbose:
        print('Running MUS for community {} on medium {}...'.format(comm_id, medium_id))

    mus = metabolite_uptake_score(community, environment=env, verbose=verbose,
                                  min_mol_weight=min_mol_weight)

    if verbose:
        print('Running MPS for community {} on medium {}...'.format(comm_id, medium_id))

    mps = metabolite_production_score(community, environment=env)

    pairs = [(org1, org2) for org1 in community.organisms
             for org2 in community.organisms if org1 != org2]

    for org1, org2 in pairs:
        if not ignore_coupling and scs[org1] is None:
            continue
        if mus[org1] is None:
            continue
        if mps[org2] is None:
            continue

        metabolites = (set(mus[org1]) | set(mps[org2])) - exclude_bigg

        for met in sorted(metabolites):
            mus_o1_met = mus[org1].get(met, 0)
            mps_o2_met = mps[org2].get(met, 0)

            if ignore_coupling:
                scs_o1_o2 = 'n/a'
                smt = mus_o1_met * mps_o2_met
            else:
                scs_o1_o2 = scs[org1][org2]
                smt = scs_o1_o2 * mus_o1_met * mps_o2_met
            smt_data.append((comm_id, medium_id, org1, org2, met, scs_o1_o2, mus_o1_met, mps_o2_met, smt))

    return smt_data


def run_abiotic(comm_id, community, medium_id, excluded_mets, env, verbose, min_mol_weight, other_mets, n, p, ignore_coupling):

    data = run_detailed(comm_id, community, medium_id, excluded_mets, env, False, min_mol_weight, ignore_coupling)

    medium = set(env.get_compounds(format_str="'{}'[7:-7]"))
    inserted = other_mets - (medium | excluded_mets)

    if len(inserted) < p:
        raise RuntimeError("Insufficient compounds ({}) to perform ({}) perturbations.".format(len(inserted), p))

    if verbose:
        print('Running {} abiotic perturbations with {} compounds...'.format(n, p))

    for i in range(n):
        new_compounds = list(medium) + sample(inserted, p)
        new_env = Environment.from_compounds(new_compounds, exchange_format="'R_EX_M_{}_e_pool'")
        new_id = "{}_{}".format(medium_id, i+1)
        entries = run_detailed(comm_id, community, new_id, excluded_mets, new_env, False, min_mol_weight, ignore_coupling)
        data.extend(entries)

    return data


def run_biotic(comm_id, community, medium_id, excluded_mets, env, verbose, min_mol_weight, other_models, model_cache,
               n, p, ignore_coupling):

    data = run_detailed(comm_id, community, medium_id, excluded_mets, env, False, min_mol_weight, ignore_coupling)

    inserted = other_models - set(community.organisms)

    if len(inserted) < p:
        raise RuntimeError("Insufficient species ({}) to perform ({}) perturbations.".format(len(inserted), p))

    if verbose:
        print('Running {} biotic perturbations with {} species...'.format(n, p))

    for i in range(n):
        new_species = list(community.organisms) + sample(inserted, p)
        comm_models = [model_cache.get_model(org_id, reset_id=True) for org_id in new_species]
        new_community = Community(comm_id, comm_models, copy_models=False, extracellular_compartment_id=ext_comp_id,
                                  create_biomass=False)
        new_id = "{}_{}".format(comm_id, i + 1)
        entries = run_detailed(new_id, new_community, medium_id, excluded_mets, env, False, min_mol_weight, ignore_coupling)
        data.extend(entries)

    return data


def export_results(mode, output, data, debug_data, zeros):

    prefix = output + '_' if output else ''

    if mode == "global":

        df = pd.DataFrame(data, columns=['community', 'medium', 'size', "mip", "mro"])
        df.to_csv(prefix + 'global.tsv', sep='\t', index=False)

        if len(debug_data) > 0:
            df = pd.DataFrame(debug_data, columns=['community', 'medium', 'key1', "key2", "data"])
            df.to_csv(prefix + 'debug.tsv', sep='\t', index=False)

    else:

        columns = ['community', 'medium', 'receiver', 'donor', 'compound', 'scs', 'mus', 'mps', 'smetana']
        df = pd.DataFrame(data, columns=columns)

        if not zeros:
            df = df.query('smetana > 0')

        df.to_csv(prefix + 'detailed.tsv', sep='\t', index=False)


def main(models, communities=None, mode=None, output=None, flavor=None, media=None, mediadb=None, zeros=False,
         ext_comp_id=None, verbose=False, min_mol_weight=False, use_lp=False, exclude=None, debug=False,
         other=None, n=1, p=1, ignore_coupling=False):

    other_models = other if mode == "biotic" else None
    model_cache, comm_dict, other_models = load_communities(models, communities, other_models, flavor)

    other_mets = other if mode == "abiotic" else None
    media, media_db, excluded_mets, other_mets = load_media(media, mediadb, exclude, other_mets)

    data = []
    debug_data = []

    for comm_id, organisms in list(comm_dict.items()):

        if verbose:
            print("Loading community: " + comm_id)

        comm_models = [model_cache.get_model(org_id, reset_id=True) for org_id in organisms]
        community = Community(comm_id, comm_models, copy_models=False, extracellular_compartment_id=ext_comp_id)

        for medium in media:

            medium_id, env = define_environment(medium, media_db, community, mode, verbose, min_mol_weight, use_lp)

            if mode == "global":
                entries, debug_entries = run_global(comm_id, community, organisms, medium_id, excluded_mets, env,
                                                     verbose, min_mol_weight, use_lp, debug)

            if mode == "detailed":
                entries = run_detailed(comm_id, community, medium_id, excluded_mets, env, verbose, min_mol_weight,
                                       ignore_coupling)

            if mode == "abiotic":
                entries = run_abiotic(comm_id, community, medium_id, excluded_mets, env, verbose, min_mol_weight,
                                      other_mets, n, p, ignore_coupling)

            if mode == "biotic":
                entries = run_biotic(comm_id, community, medium_id, excluded_mets, env, verbose, min_mol_weight,
                                     other_models, model_cache, n, p, ignore_coupling)

            data.extend(entries)

            if debug:
                debug_data.extend(debug_entries)

    export_results(mode, output, data, debug_data, zeros)

    if verbose:
        print('Done.')


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description="Calculate SMETANA scores for one or multiple microbial communities.",
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('models', metavar='MODELS', nargs='+',
                        help=textwrap.dedent(
        """
        Multiple single-species models (one or more files).
        
        You can use wild-cards, for example: models/*.xml, and optionally protect with quotes to avoid automatic bash
        expansion (this will be faster for long lists): "models/*.xml". 
        """
        ))

    parser.add_argument('-c', '--communities', metavar='COMMUNITIES.TSV', dest='communities',
                        help=textwrap.dedent(
        """
        Run SMETANA for multiple (sub)communities.
        The communities must be specified in a two-column tab-separated file with community and organism identifiers.
        The organism identifiers should match the file names in the SBML files (without extension).
        
        Example:
            community1\torganism1
            community1\torganism2
            community2\torganism1
            community2\torganism3
            
        """
    ))

    parser.add_argument('-o', '--output', dest='output', help="Prefix for output file(s).")
    parser.add_argument('--flavor', help="Expected SBML flavor of the input files (cobra or fbc2).")
    parser.add_argument('-m', '--media', dest='media', help="Run SMETANA for given media (comma-separated).")
    parser.add_argument('--mediadb', help="Media database file")

    mode = parser.add_mutually_exclusive_group()
    mode.add_argument('-g', '--global', dest='global', action='store_true', help="Run global analysis with MIP/MRO (faster).")
    mode.add_argument('-d', '--detailed',  dest='smetana', action='store_true', help="Run detailed SMETANA analysis (slower).")
    mode.add_argument('-a', '--abiotic',  dest='abiotic', help="Test abiotic perturbations with given list of compounds.")
    mode.add_argument('-b', '--biotic',  dest='biotic', help="Test biotic perturbations with given list of species.")

    parser.add_argument('-p', type=int, default=1, help="Number of components to perturb.")
    parser.add_argument('-n', type=int, default=1, help="Number of perturbation experiments.")

    parser.add_argument('-v', '--verbose', action='store_true', dest='verbose', help="Switch to verbose mode")
    parser.add_argument('-z', '--zeros', action='store_true', dest='zeros', help="Include entries with zero score.")
    parser.add_argument('--solver', help="Change default solver (current options: 'gurobi', 'cplex').")
    parser.add_argument('--ext', help="Extracellular compartment identifier in the models (default 'C_e').")
    parser.add_argument('--molweight', action='store_true', help="Use molecular weight minimization (recomended).")
    parser.add_argument('--lp', action='store_true', help=argparse.SUPPRESS)
    parser.add_argument('--exclude', help="List of compounds to exclude from calculations (e.g.: inorganic compounds).")
    parser.add_argument('--debug', action='store_true', help=argparse.SUPPRESS)
    parser.add_argument('--no-coupling', action='store_true', help="Ignore species coupling scores.")

    args = parser.parse_args()

    if args.smetana:
        mode = "detailed"
        other = None
    elif args.abiotic:
        mode = "abiotic"
        other = args.abiotic
    elif args.biotic:
        mode = "biotic"
        other = args.biotic
    else:
        mode = "global"
        other = None

    if args.debug and mode != "global":
        parser.error('For the moment --debug is only available in global mode.')

    if args.solver:
        set_default_solver(args.solver)

    ext_comp_id = args.ext if args.ext else 'C_e'

    main(
        models=args.models,
        communities=args.communities,
        mode=mode,
        output=args.output,
        flavor=args.flavor,
        media=args.media,
        mediadb=args.mediadb,
        zeros=args.zeros,
        ext_comp_id=ext_comp_id,
        verbose=args.verbose,
        min_mol_weight=args.molweight,
        use_lp=args.lp,
        exclude=args.exclude,
        debug=args.debug,
        other=other,
        p=args.p,
        n=args.n,
        ignore_coupling=args.no_coupling,
    )


